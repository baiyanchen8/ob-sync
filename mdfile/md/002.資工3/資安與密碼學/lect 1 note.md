---
title: 'lect 1 note '
tags: [密碼學]

---


精老烏龜

## 術語
明文（plainttext）:原始有意義的訊息
密文(ciphertext):加密後的訊息
金鑰:加密器的重要資訊
加密
解密

## 安全原理假設
密碼學必定僅依賴你的金鑰，而非依賴演算法，必須假設對方知道加密方式

## 破解法

1. 只知密文攻擊:
    只能透過密文分析（ex: 統計分析）
2. 已知明文分析
    已知部分明文&其對應密文分析
3. 選擇密文分析
   攻擊者掌握對**解密機**的存取權限，可構造任意密文所對應的明文。
4. 選擇明文攻擊
    攻擊者擁有**加密機**的訪問許可權，可構造任意明文所對應的密文。

    
   
   
## 理論安全&實際安全
***理論安全***
- 理論絕對安全 ： 不管破密者有多強的計算力，都無法解密（理論上 OTP 可達成 ，but 實際上 OTP 無法實現）
- 破解密文的機率=直接猜對明文的機率，稱為密碼元件的理論安全
>  gpt
> 
> 一次性密鑰（One-time pad）是密碼學中的一種理論安全的加密方法。它使用了一個完全隨機且僅使用一次的密鑰來對消息進行加密。這個密鑰必須與消息長度相同，並且只能使用一次，因此被稱為「一次性」密鑰。
> 
> 一次性密鑰的理論安全性源於以下原因：
> 
> 完美保密性（Perfect Secrecy）：只要密鑰足夠長且完全隨機，且每個密鑰都僅用一次，就能夠保證密文提供了對明文來說毫無信息的洩漏，即使攻擊者擁有所有密文，也無法推斷出明文或密鑰的任何信息。
> 不可破解性：由於無法利用密文進行密碼分析或猜測密鑰，因此即使攻擊者擁有無限的計算資源，也無法破解出原始消息或密鑰。
> 然而，儘管一次性密鑰提供了理論上的安全性保證，但實際應用上存在諸多限制。其中最主要的問題是密鑰的生成、傳遞和管理。由於密鑰必須與消息一樣長且完全隨機，而且每個密鑰只能使用一次，因此需要大量的隨機性且具有安全通道來交換密鑰。此外，一次性密鑰不能重複使用，因此需要大量的密鑰來支持長時間的通信。
> 
> 總的來說，儘管一次性密鑰在理論上提供了最高層次的安全性，但在實際應用上因為其困難的密鑰管理和使用限制而很少被使用。


***實際安全***
- 若無法達成理論安全則會以實際安全為準
- 實際安全指，破密代價過高，以至於破密這意行為的不切實際
>  gpt
在密碼學中，「實際安全」指的是一種加密方案的安全性，這種安全性不僅在於理論上的保證，還考慮了實際應用中可能存在的攻擊和限制。

實際安全的加密方案需要考慮以下因素：

計算複雜性：加密算法是否能夠抵抗實際存在的計算攻擊，即使攻擊者擁有大量計算資源。

密鑰管理：密鑰的生成、分配、存儲和更新是否能夠保證安全，並且不易受到內部或外部的攻擊。

安全協議：加密方案是否與安全通訊協議相結合，以確保在消息傳輸過程中不會遭受中間人攻擊或窺探。

實際環境：考慮到實際應用的環境和限制，如帶寬、存儲空間、計算資源等，加密方案是否能夠在這些限制下運作。

安全性分析：針對實際應用中可能遇到的各種攻擊，進行全面的安全性分析和測試。

總的來說，實際安全的加密方案需要在理論安全性的基礎上，考慮到現實中的各種因素和限制，並且能夠有效地應對可能的攻擊和威脅。

![image](BJ0qqnQl0.png)

W(n):
理論工作函數，理論的最少代價
Wh(n):
實際工作函數，已知的最小代價

![image](HJeyo2QlA.png)

# 密碼系統之分類
## 分類方式
![image](Hyvkp3Qg0.png)

##  對稱式加密 & 公開金鑰加密
- Secret-key encryption 
    - 又稱對稱加密
    - 其安全性依賴於攻擊者不知道通訊雙方的"secret key"
    - 加密 ＆ 解密的 key 相同
- Public-key encryption
    - 又稱非對稱式加密
    - 安全性取決於發送者和接收者擁有一些共同的可信訊息，並且假設敵方密碼分析者也知道這些資訊。
    - 加密 ＆ 解密的 key 不相同 （加密使用公鑰，解密使用私鑰）
![image](H1KH-OIeA.png)

## Compare

![image](SJZkWO8eR.png)

# 私鑰加密

## 古典技術

![image](HyQtSu8l0.png)
![image](rypFBOIlR.png)
## 現代技術
以代換 (Substitution) 及換位 (Transposition)為基本轉換方式，其運算速度快，適合用於大量資料之加解密。

現代秘密金鑰加密以區塊加密器的使用最為廣泛
一般區塊密文 (Block Cipher) 加密器之設計，須注意到以下特性
- 迷惑性：明文及密文對金鑰的關係無法用數學式分析
- 擴散性：改變明文或金鑰的任一位元，密文之所有位元均可能影響
- 規則性：以利實現
- 簡單性：快速運算
- 相似性：加密器解密器相同以節省成本

1976 :  DES

2000 : RBC 

2002 : AES

# 公開金鑰加密
- 通常是基於數學難題本身，運算速度慢，但無須考慮金鑰之分配，用於較少量之資料加解密，如保護對話金鑰或使用者之個人資訊。
-  NOTE：公開金鑰加密與數位簽章 (Digital Signature) 均為一組 Public Key 與 Private Key，若是使用者的 Public Key 有認證憑據(Certification)，則此 Public Key 可用作身分鑑別 (Authentication)。

## 公開加密的基礎
1. 常見的數學運算
2. 有限體
3. 主要的數學難題


### 常見的數學運算 

module

### 有限體
「有限體」是數學中的概念，特指一種有限個元素的數域。在代數結構上，有限體是一個包含有限個元素的集合，其中定義了加法和乘法運算，滿足一些特定的性質，如封閉性、結合律、交換律、存在唯一零元素和存在唯一單位元素等。在有限體中，通常也有除法運算，但並不是所有元素都可進行除法。例如，有限體GF(2)是一個包含0和1兩個元素的有限體，代表了二進制位元的加法和乘法運算。

### 主要的數學難題
- 許多密碼系統(尤其公鑰密碼系統)之安全基礎植基於數學難題之上，這些數學難題須具有以下特徵之一
    - 單向函數 (One-way Function)
        - 一函數 𝑦 = 𝑓( 𝑥 )，求 𝑓(𝑥)容易但是求 $f^{1}(y)$ 困難。
    - 單向暗門函數 (One-way Trapdoor Function)
        - 一函數 𝑦 = 𝑓( 𝑥 )，求 𝑓 𝑥 容易但是求  $f^{1}(y)$ 困難，但若已知某額外資訊，則不難求出 $f^{1}(y)$。


### Merkle Puzzle 

梅克爾拼圖的流程通常涉及以下步驟：

密鑰產生：

發送方產生大量的金鑰對，每個金鑰對包含一個公鑰和一個對應的私鑰。 這些密鑰對以某種方式關聯，通常是透過一種密碼學函數。
拼圖生成：

對於每個私鑰，發送方會建立一個對應的拼圖。 拼圖的產生通常涉及將私鑰分解成一些片段，然後應用某種轉換或混淆，使其變成一個難以解密的拼圖。
拼圖分發：

發送方將所有拼圖分發給多個接收方，可能透過不安全的通訊管道。 每個接收方會收到一個拼圖集合，但不知道其中任何一個拼圖的私鑰。
拼圖解密：

每個接收者嘗試解密收到的拼圖，以獲得其中包含的私鑰。 解密過程可能需要耗費大量的運算資源和時間，這取決於拼圖的複雜性和數量。
密鑰匹配：

一旦接收者成功解密了一個拼圖，他們就獲得了其中包含的私鑰。 接收者可以將私鑰與相應的公鑰進行匹配，從而建立安全通訊的金鑰對。
透過這個過程，發送方可以在不安全的通訊管道上安全地向多個接收方分發金鑰。 即使拼圖被截獲，攻擊者也需要大量的運算資源才能成功解密它們，從而保護了金鑰的安全性。

### Diffie-Hellman 金鑰交換協定
Diffie-Hellman金鑰交換協定是一種密碼學中的協定，用於安全地在不安全的通信環境中交換密鑰。該協定於1976年由惠特菲爾德·迪菲（Whitfield Diffie）和馬丁·赫爾曼（Martin Hellman）提出。

這個協定的基本思想是，兩個通信方可以在不直接交換密鑰的情況下協商出一個共享的密鑰。該密鑰可以用於後續的加密通信，以確保通信的保密性。

Diffie-Hellman金鑰交換協定的運作過程如下：

1. **參數生成**：事先選擇一些公開的參數，包括一個大質數$p$和一個原根$g$。這些參數可以被所有通信方共享。
2. **金鑰協商**：
   - 雙方各自選擇一個私密的數a和b作為自己的私鑰。
   - 雙方利用公開的參數$p$和$g$，分別計算出 $A = g^a\mod p$ 和 $B = g^b \mod p$。
   - 雙方交換$A$和$B$。
   - 雙方分別使用自己的私鑰和收到的對方的$A$或$B$，計算出共享的金鑰。具體地，若Alice收到了Bob的$B$，她計算$K = B^a \mod p$；若Bob收到了Alice的$A$，他計算$K = A^b \mod p$。
3. **金鑰確認**：雙方通過某種方式確認共享的金鑰是否正確，通常是通過加密一個挑戰性的消息並將其發送給對方進行確認。

Diffie-Hellman協定的安全性基於離散對數問題的困難性，即計算$g^x \mod p$的反函數，即已知$g$、$p$和$A = g^x \mod p$，求解$x$的困難性。只要$p$和$g$足夠大，攻擊者需要耗費極大的計算資源才能成功破解共享金鑰。
![image](SkxMQ3PlR.png)


### RSA 加密演算法
RSA是一種非對稱加密算法，由Ron Rivest、Adi Shamir和Leonard Adleman在1977年提出。RSA算法基於數學中的兩個重要問題：大數因式分解和模指數運算。

RSA算法的運作過程如下：

1. **金鑰生成**：
   - 選擇兩個大質數$p$和$q$，計算它們的乘積$n = p \times q$。
   - 計算$n$的歐拉函數$\phi(n) = (p - 1) \times (q - 1)$。
   - 選擇一個整數\(e\)，使得$1 < e < \phi(n)$，且$e$與$\phi(n)$互質。
   - 計算$d$，使得$d \times e \equiv 1 \pmod{\phi(n)}$。
   - 公鑰為$(n, e)$，私鑰為$(n, d)$。

2. **加密**：
   - 將明文消息轉換為整數$m$，滿足$0 \leq m < n$。
   - 使用公鑰中的指數$e$，計算密文$c \equiv m^e \pmod{n}$。

3. **解密**：
   - 使用私鑰中的指數$d$，計算密文$c$的解密結果$m \equiv c^d \pmod{n}$。

RSA算法的安全性基於大數因式分解問題的困難性，即對於一個大數$n$，找到其兩個素因數$p$和$q$的乘積。只要$p$和$q$足夠大且保密，破解RSA加密就需要耗費極大的計算資源。


對，你說得對。這些都是RSA加密算法的關鍵原理和漏洞。我們來分別解釋一下：

1. 如果知道RSA公鑰$N$的兩個質因數$p$和$q$，就可以輕易地計算出歐拉函數$\phi(N)$的值。因為根據歐拉定理，$\phi(N) = (p - 1)(q - 1)$。所以，如果攻擊者知道$N$的因數$p$和$q$，就可以計算出$\phi(N)$的值，進而導出私鑰$d$。

2. RSA中的公鑰$e$通常是一個固定的值，通常是65537或者其他選定的素數。因此，攻擊者通常可以很容易地獲取到公鑰$e$的值。如果攻擊者知道$\phi(N)$，就可以使用歐拉定理計算出私鑰$d$。這是因為$d$是滿足$e \cdot d \equiv 1 \pmod{\phi(N)}$的唯一解，即$d = e^{-1} \pmod{\phi(N)}$。

3. RSA的安全性基於大數分解問題的困難性，即在給定$N$的情況下，找到$N$的兩個質因數$p$和$q$。如果攻擊者可以有效率地分解大數，那麼他們就能夠獲取到RSA的私鑰$d$，從而破解加密的消息，這將導致RSA密碼系統的完全失效。

### 模糊傳輸 (Oblivious Transfer)
模糊傳輸（Oblivious Transfer，OT）是一種密碼學原語，用於在通訊雙方之間進行信息傳輸，其中發送方只傳送一個消息給接收方，而接收方只能選擇其中的一個消息接收，而不讓發送方得知接收方選擇的是哪一個消息。

模糊傳輸可以用於保護個人隱私和實現安全協議，例如，用於實現安全的選票系統、身份認證和私密通訊。

一個簡單的示例是 1-out-of-2 模糊傳輸，其中發送方有兩個消息，而接收方只能選擇其中一個消息接收。在一個安全的 1-out-of-2 模糊傳輸協議中，即使發送方和接收方可能是不可信的，但接收方可以確保發送方不會得知他選擇了哪個消息。

Oblivious Transfer可以通過各種技術和協議來實現，包括零知識證明、擴展零知識證明、同態加密等。这些技术可以确保接收方在选择消息时，发送方无法获知接收方的选择，从而保护了接收方的隐私。
### 零知識證明 
零知識證明（Zero-knowledge Proof，ZKP）是一種加密學概念，用於證明某個陳述是真實的，而不需透露陳述的具體內容或信息。換句話說，零知識證明允許一方（證明者）向另一方（驗證者）證明某件事情的真實性，而不需要透露任何有關這件事情的細節。

在零知識證明中，證明者只需向驗證者證明他擁有某個特定的信息，而無需透露這個信息的內容。換句話說，零知識證明不僅能夠確保所證明的陳述是真實的，還能夠確保證明過程是零知識的，即證明過程不泄漏任何有關證明的信息。

零知識證明在加密學和計算機科學中有許多應用，例如：
- 在身份驗證系統中，用戶可以通過零知識證明證明他們擁有某個特定的身份，而無需透露其他個人信息。
- 在區塊鏈和加密貨幣中，零知識證明可以用於證明交易的有效性，而不需要透露交易的細節。
- 在安全計算中，零知識證明可以用於證明兩個計算方在執行某個計算時的準確性，而無需透露計算的具體內容。

零知識證明的實現通常使用各種加密學技術，如同態加密、零知識範例和非交互式零知識證明。这些技术允许證明者向验证者证明某个事实的真实性，而不必泄露关于这个事实的任何信息。

### 同态加密
同态加密（Homomorphic Encryption）是一种特殊的加密技术，允许在加密状态下执行计算，并在密文上执行操作，得到的结果与在明文上执行相同操作后的结果相同。换句话说，同态加密允许在加密数据上进行计算，而无需将其解密。

同态加密的主要优势在于可以在不泄露数据隐私的情况下进行计算。这对于云计算、数据共享和隐私保护等应用非常有用，因为数据可以保持加密状态，而无需将其解密，即可进行计算。

同态加密可分为几种不同类型，包括：
- 加法同态加密（Additive Homomorphic Encryption）：允许在加密状态下执行加法操作。
- 乘法同态加密（Multiplicative Homomorphic Encryption）：允许在加密状态下执行乘法操作。
- 完全同态加密（Fully Homomorphic Encryption）：允许在加密状态下执行任意计算操作，包括加法、乘法以及其他运算。

虽然同态加密在理论上非常强大，但实际上执行同态计算可能会带来一定的计算和性能开销。目前，仍然存在一些限制和挑战，包括性能、安全性和实用性等方面的问题。然而，随着加密技术的不断发展和改进，同态加密正在成为实现安全计算和隐私保护的重要工具之一。


### 單項雜湊函式
- 功能
    - 已給任意長度之輸入 𝑥，可求得固定長度之輸出 ℎ(𝑥)。
- 用途
    - 配合數位簽章使用以加快數位簽章之速度及增加安全性。
- 常用之單向雜湊函數 (One-way Hash Function)
    - MD5、SHA-1、SHA-2、SHA-3 …

![image](Sk2gu4weR.png)
![image](rkwbO4PeC.png)
![image](SJnNONDg0.png)


