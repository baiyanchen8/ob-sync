# I/O Hardware
## I/O Hardware
- Variety of I/O device
	- Storage
		- HDD、SSD
	- Transmission
		- internet interface
	- Human-interface
		- keyboard
- ***Common concept***
	- **Port**
		- connection point for device
		- ex: thunderbolt、usb port、SATA、HDMI...
	- **Bus**
		- A set of *wire* and define *protocol*
		- Can be *daisy chain* 、p2p、or hub(1-多) 
			- *daisy chain*:通常是指將多個裝置依序串接在一起，形成一個鏈狀結構。
				- \![[Pasted image 20241008223914.png|example]]
		- PCIe bus(system bus)、expansion bus(I/O bus)
			- \![[Pasted image 20241008224625.png|example]]
	- **Device Controller**
		- A collection of ***electronics***  and can operate a port ,a bus or a device
			- 電子設備的集合，可操作連接埠、匯流排或設備
		- \![[Pasted image 20241008225941.png]]
### Internal Structure of a  Device
- Simple: a few hardware chips
	- keyboard
- Complex: include CPU,memory,some device-specific chip(可以執行一些軟體)
	- frimware running on CPU
	- SSD,無線網路晶片
![[Pasted image 20241008231602.png]]
### Hardware Interface
> [!question] How to give commands and data to controller ?
> - by register

![[Pasted image 20241008231802.png]]
## A Simplified I/O Hardware

![[Pasted image 20241009092917.png]]
![[Pasted image 20241009092904.png]]
![[Pasted image 20241009093734.png]]
![[Pasted image 20241009095122.png]]
- polling -> busy waiting
- programmed i/o(pio/cpu io)
	- 使用 cpu transfer data (沒效率cpu)
### sol for polling
![[Pasted image 20241009101302.png]]
![[12.OS 2024-10-09 10.16.39.excalidraw|599]]
### sol for programmed i/o [[DMA]]
![[Pasted image 20241009102145.png]]
![[Pasted image 20241009102634.png]]
 
## Method of Device Interaction
> [!question] How to communicate with devices？
> 	＝ how to read/write these device registers？

> [!sol] **sol：** assign each device reg a num,id or address

> [!question] address 如何決定？

![[Pasted image 20241009104617.png]]
- Port-mapped
![[Pasted image 20241009105205.png]]
- memory mapp
![[Pasted image 20241009133706.png]]
![[Pasted image 20241009133717.png]]

## Polling
- **busy waiting** or **polling**
	- 大部份情況下皆 *不 ok*
- if 不使用 polling, 使用 interrupt 處理 
	- 由 device *notify* CPU
- **忙碌等待（Busy-wait）適合的環境**：在高吞吐量的系統中，I/O 可能非常頻繁，且處理器無法承受因處理中斷造成的性能開銷。Polling 在這種情況下可以避免 interrupt 引發的 overhead 。
## Interrupt
- How CPU knows an interrupt occurs ?
	-  CPU has a wire called ***interrupt-request line***
	- if it is set to 1 , CPU senses interrupt.
![[Pasted image 20241009211639.png]]
![[Pasted image 20241009212658.png]]

> [!bug] ***BUT*** Interrupt is not free!!
> interrupt has overhead,並且有可能超過之前的好處
>![[Pasted image 20241009213148.png]]
>![[Pasted image 20241011093115.png]]
>![[Pasted image 20241011093220.png]]

### FLIH(first level interrupt handler) ＆ SLIH(second level interrupt handler)
- FLIH 
	- 必須被立即執行,當 interrupt 發生
- SLIH 
	- SLIH 是由 FLIH 觸發或調用的次級中斷處理程序，負責處理更多細節和複雜的工作。
	- **主要功能**：它通常負責完成 FLIH 來不及處理的耗時操作，例如數據緩存、資料傳輸或者與驅動程式和應用程式的溝通。
	- **運行速度**：相較於 FLIH，SLIH 可以運行得稍慢一些，因為它不需要立即回應中斷信號，而是完成後續的處理。
	- **特性**：SLIH 可以處理較多的背景工作，像是更新內部狀態、啟動裝置驅動程式、或者為應用程式準備資料等。
- in Linux
	- FLIH is called upper half
	- SLIH is called lower half or bottom half

### trap & innterrupt [[1.OS]]
- interrupt
	- 處理 asynchronous(非同步) 的 event
- trap(Exception)
	- 處理 synchronous(同步) 的 event
	- system call & error

## Direct Memory Acess[[DMA]]
# Application I/O interface

# Kernel I/O Subsystem 
# Transforming I/O Requests to Hardware Operations
# Streams
# Performance

